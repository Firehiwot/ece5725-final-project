<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ECE 5727 Modulator</title>
  </head>
  <body>
    <p>
      <label for="bits">Bits to send:</label>
      <input type="text" id="bits" value="0001101111001010">
      <button id="play-sound">Play Sound</button>
    </p>

    <script>
      document.getElementById("play-sound").addEventListener("click", function(e) {
        e.preventDefault();

        // Get the bits
        var bits = document.getElementById("bits").value.trim().split('');
        modulate(bits);
      }, false);

      var audioContext = typeof AudioContext != "undefined" ?
        new AudioContext() : new webkitAudioContext();

      String.prototype.replaceAt = function(index, replacement) {
        return this.substr(0, index) + replacement +
               this.substr(index + replacement.length);
      }

      /**
       * Compute the CRC remainder for a bitstring.
       *
       * @param bits {String} The bitstring
       * @param poly {String} The CRC polynomial bitstring
       * @param pad  {String} The padding to put after the bitstring (optional,
       *                      defaults to all zeros)
       *
       * @return {String} The CRC remainder
       */
      function calcCrc(bits, poly, padding) {
        // Right pad the bitstring with as many zeros as the length of the
        // polynomial
        if (padding == undefined) {
          var padding = [];
          for (var i = 0; i < poly.length - 1; i++) {
            padding.push("0");
          }
        }
        var paddedBits = bits.slice(0).concat(padding);

        var numBits = bits.length;
        while (paddedBits.slice(0, numBits).indexOf("1") != -1) {
          var currShift = paddedBits.indexOf("1");
          for (var i = 0; i < poly.length; i++) {
            if (poly[i] == paddedBits[currShift + i]) {
              paddedBits[currShift + i] = "0";
            }
            else {
              paddedBits[currShift + i] = "1";
            }
          }
        }

        return paddedBits.slice(numBits, numBits + poly.length - 1);
      }

      /**
       * Modulate bits into frequencies.
       */
      function modulate(bits) {
        // Define modulation parameters
        var Fs = audioContext.sampleRate;
        var Fc = 350;
        var Fmod = 50;
        var bitRate = 4;
        var sampPerBit = Math.floor(Fs / bitRate);

        bits = bits.concat(calcCrc(bits, "11011"));

        // Convert the bits into an array of frequencies
        var freqs = [];
        function pushFreq(freq) {
          for (var j = 0; j < sampPerBit; j++) {
            freqs.push(freq);
          }
        }
        for (var i = 0; i < bits.length; i += 2) {
          var chunk = bits[i] + bits[i+1];
          if (chunk == "00") {
            pushFreq(400);
          }
          else if (chunk == "01") {
            pushFreq(500);
          }
          else if (chunk == "10") {
            pushFreq(600);
          }
          else if (chunk == "11") {
            pushFreq(700);
          }
        }

        // Create an audio buffer
        var duration = freqs.length;
        var startLen = 3*Fs;
        var numChannels = 1;
        var buffer = audioContext.createBuffer(numChannels, duration+startLen, Fs);

        // Fill the channel with the desired frequency data
        var channelData = buffer.getChannelData(0);
        for (var i = 0; i < startLen; i++) {
          channelData[i] = Math.sin(2*Math.PI*(Fc-Fmod)*i/Fs);
          channelData[i] += Math.sin(2*Math.PI*(Fc+Fmod)*i/Fs);
        }
        for (var i = 0; i < duration; i++) {
          channelData[i+startLen] = Math.sin(2*Math.PI*freqs[i]*i/Fs);
        }

        // Create audio source node
        var source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);

        // Play the sound
        source.start();
      }
    </script>
  </body>
</html>
